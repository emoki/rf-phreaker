/*==============================================================================
	This source file demonstrates usage of EnDec
==============================================================================*/
#include "ed_c_recog.h"
#include "Uplink.h"
#include "Downlink.h"
#include "GSM0816.h"
#include "CSN1DataTypes.h"
#include <stdio.h>
#include <errno.h>
#include "ed_c_dump.h"
#include "ed_dump_file.h"


/*------------------------------------------------------------------------------
	This function receives a char buffer containing an encoded message. It will
	try to decode it and print some of its contents.
	Buffer 'Source' contains a message 'LenInBytes' bytes long.
------------------------------------------------------------------------------*/
void DecodeAndPrint (const char* Source, int LenInBytes)
{
	/*
		This is an union containing c structures for every declared
		message. 
	*/
	TUplink_Data Message;

	/* 
		Try to recognize and decode the message, using a function
	  that has been generated by EnDec 
	*/
	if (Decode_Uplink (Source, LenInBytes, &Message) == ED_TRUE) {
		switch (Message.Type) {
			
			/*------------------------------------------------------------------------
				It is an ATTACH REQUEST
			------------------------------------------------------------------------*/
			case ID_Uplink_ATTACH_REQUEST:
				printf ("Recognized an Attach Request\n");
				printf ("  Attach type: %d\n", Message.Data.fld_c_ATTACH_REQUEST.AttachType.TypeOfAttach);

				/* Print MSNetworkCapability */
				printf ("  MS Network Capability\n");
				printf ("    GEA/1: %s\n", Message.Data.fld_c_ATTACH_REQUEST.MSNetworkCapability.GEA_1? "true":"false");
				printf ("    SM capabilities via dedicated channels: %s\n", Message.Data.fld_c_ATTACH_REQUEST.MSNetworkCapability.SM_capabilities_via_dedicated_channels? "true":"false");
				printf ("    SS Screening Indicator: %d\n", Message.Data.fld_c_ATTACH_REQUEST.MSNetworkCapability.SS_Screening_Indicator);
	
				/* If OldPTMSISignature is present, print it */
				if (Message.Data.fld_c_ATTACH_REQUEST.OldPTMSISignature_Present) {
					printf ("  Old PTMSI Signature is present: %02x%02x%02x\n", 
						Message.Data.fld_c_ATTACH_REQUEST.OldPTMSISignature [0],
						Message.Data.fld_c_ATTACH_REQUEST.OldPTMSISignature [1],
						Message.Data.fld_c_ATTACH_REQUEST.OldPTMSISignature [2]);
				}
				/* OldPTMSISignature is not present... */
				else {
					printf ("  Old PTMSI Signature is not present\n");
				}
				break;

			/*------------------------------------------------------------------------
				It is an AUTHENTICATION AND CIPHERING REQUEST
			------------------------------------------------------------------------*/
			case ID_Uplink_AUTHENTICATION_AND_CIPHERING_REQUEST:
				printf ("Detected an AUTHENTICATION AND CIPHERING REQUEST\n");
				/* do all processing... */
				break;
		}
	}
	else {
		printf ("Message not understood!\n");
	}
}

/*------------------------------------------------------------------------------
	This function receives a char buffer containing an encoded message. It will
	try to decode it and print its content using EnDec "dump" module.
	Buffer 'Source' contains a message 'LenInBytes' bytes long.
------------------------------------------------------------------------------*/
void DecodeAndDump (const char* Source, int LenInBytes)
{
	/*
		This is the printing object
	*/
	TEDOStreamFile OStream;

	/*
		This is an union containing c structures for every declared
		message. 
	*/
	TUplink_Data Message;

	/*
		Initialize the printing object, so it prints on a file
	*/
	if (TEDOStreamFile_Construct (&OStream, "values.txt", "w")) {
		printf ("Error opening 'values.txt' (%s)\n", strerror (errno));
		return;
	}

	/* 
		Try to recognize and decode the message, using a function
	  that has been generated by EnDec 
	*/
	if (Decode_Uplink (Source, LenInBytes, &Message) == ED_TRUE) {
		Dump_Uplink ((TEDOStream*)&OStream, &Message);
	}
	else {
		printf ("Message not understood!\n");
	}

	/*
		Destruct the stream object
	*/
	TEDOStreamFile_Destruct (&OStream);

}

/*------------------------------------------------------------------------------
	MAIN
------------------------------------------------------------------------------*/
int main (void)
{
	/* Buffer to be used for encoding tests */
	char Buffer [128];
	int Len, i;

	/*----------------------------------------------------------------------------
		First test: lets try to decode some messages
	----------------------------------------------------------------------------*/
	{
		/* Here we simulate encoded buffers received from a lower layer */
		const char Msg1[] = {'\x08', '\x01', '\x01', '\xff', '\x31', '\x19', '\x01', '\x02', '\x03'};
		DecodeAndPrint (Msg1, sizeof (Msg1));
		DecodeAndDump (Msg1, sizeof (Msg1));

		/* We can also use the "Match_xxx" functions, generated by EnDec */
		/* They allow us to test a buffer and understand if it contains a */
		/* given message */
		if (Match_c_ATTACH_REQUEST (Msg1, 0)) printf ("It contains an Attach Request\n");
		else printf ("It does not contain an Attach Request\n");

		if (Match_c_AUTHENTICATION_AND_CIPHERING_REQUEST (Msg1, 0)) printf ("It contains an Authentication Request\n");
		else printf ("It does not contain an Authentication Request\n");
	}

	/*----------------------------------------------------------------------------
		Second test: lets try to encode some messages
	----------------------------------------------------------------------------*/
	{
		c_ATTACH_REQUEST AttachRequest;
		
		/* Prepare the message structure */
		INIT_c_ATTACH_REQUEST (&AttachRequest);

		/* Fill out the right fields */
		AttachRequest.AttachType.FORx = ED_TRUE;
		AttachRequest.AttachType.TypeOfAttach = 2;
		AttachRequest.MSNetworkCapability.GEA_1 = ED_FALSE;
		AttachRequest.MSNetworkCapability.SM_capabilities_via_dedicated_channels = ED_TRUE;

		/* Encode the message */
		Len = ENCODE_c_ATTACH_REQUEST (Buffer, 0, &AttachRequest);

		/* Dump the message on standard output */
		printf ("Encoded message: ");
		for (i=0; i<Len/8; i++) {
			printf ("%02X", (unsigned)((unsigned char)Buffer[i]));
		}
		printf ("\n");

		/* Free the message structure */
		FREE_c_ATTACH_REQUEST (&AttachRequest);
	}

	/*----------------------------------------------------------------------------
		Third test: single information elements can be encoded/decoded if
		necessary.  We now encode and decode a CSN.1 information element.
	----------------------------------------------------------------------------*/
	{
		c_MS_network_capability_value_part ncvp1, ncvp2;
		INIT_c_MS_network_capability_value_part (&ncvp1);
		ncvp1.GEA_1 = ED_TRUE;
		ncvp1.UCS2_support = ED_TRUE;
		ncvp1.SS_Screening_Indicator = 2;

		/* Encode it */
		Len = ENCODE_c_MS_network_capability_value_part (Buffer, 0, &ncvp1);

		/* Now decode it */
		DECODE_c_MS_network_capability_value_part (Buffer, 0, &ncvp2, Len);
		
		{
			unsigned offset = ED_LOCATOR_GET_OFFSET (&ncvp2.UCS2_support___LOCATOR);
			unsigned length = ED_LOCATOR_GET_LENGTH (&ncvp2.UCS2_support___LOCATOR);
			unsigned valid = ED_LOCATOR_IS_VALID (&ncvp2.UCS2_support___LOCATOR);
			if (valid) printf ("Field 'UCS2_support' is encoded at offset=%u length=%u\n", offset, length);
			else printf ("Field 'UCS2_support' is encoded at an unknown position\n");
		}

		FREE_c_MS_network_capability_value_part (&ncvp1);
	}

	/*----------------------------------------------------------------------------
		Now let's try to encode a 08.16 message
	----------------------------------------------------------------------------*/
	{
		int Len2;
		c_SUSPEND Suspend, Suspend2;
		INIT_c_SUSPEND (&Suspend);
		INIT_c_SUSPEND (&Suspend2);
		Suspend.RouteingArea.LAC = 120;
		Suspend.RouteingArea.MCC1 = 1;
		Suspend.RouteingArea.MCC2 = 2;
		Suspend.RouteingArea.MCC3 = 3;
		Suspend.RouteingArea.MNC1 = 4;
		Suspend.RouteingArea.MNC2 = 5;
		Suspend.RouteingArea.RAC  = 11;
		Suspend.TLLI = 2112;

		Len = ENCODE_c_SUSPEND (Buffer, 0, &Suspend);
		if (Len < 0) printf ("Error encoding 'SUSPEND' message\n");

		/* Now "Buffer" contains an encoded "Suspend" message */
		/* Let's try to decode it */
		Len2 = DECODE_c_SUSPEND (Buffer, 0, &Suspend2, Len);

		if ((Len == Len2) && (memcmp (&Suspend, &Suspend2, sizeof (Suspend)) == 0)) {
			printf ("Ok, SUSPEND test succesfull\n");
		}
		else {
			printf ("Error: SUSPEND test unsuccesfull\n");
		}

		FREE_c_SUSPEND (&Suspend);
		FREE_c_SUSPEND (&Suspend2);
	}

	return 0;
}